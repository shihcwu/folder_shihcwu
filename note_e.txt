>> java -version

>> cd C:\Users\software\elasticsearch\elasticsearch-6.2.1\bin
>> elasticsearch
http://localhost:9200/

>> cd C:\Users\software\elasticsearch\kibana-6.2.1-windows-x86_64\bin
>> kibana
http://localhost:5601

# --- load data using _bulk
>> curl -H "Content-Type: application/json" -XPOST "localhost:9200/mydata/app/_bulk?pretty&refresh" --data-binary "@data.json"
>> curl -H "Content-Type: application/json" -XPOST "localhost:9200/mydata/app/_bulk?pretty&refresh" --data-binary "@data_1.csv" && curl -H "Content-Type: application/json" -XPOST "localhost:9200/mydata/app/_bulk?pretty&refresh" --data-binary "@data_2.csv"

>> curl "localhost:9200/_cat/indices?v"

# --- load data using logstash
>> bin/logstash -e "input { stdin { } } output { stdout {} }"
>> cd C:\Users\software\elasticsearch\logstash-6.2.1\bin
>> logstash -f logstash_cars.conf

# --- logstash config file (file name cannot be too long)
input {
    file {
		path => "/Users/data/data.csv"
		start_position => "beginning"
		sincedb_path => "/dev/null"
	}
}
filter {
    csv {
	    separator => ","
		columns => [ "maker", "model", "mileage", "manufacture_year", 
		"engine_displacement", "engine_power", "body_type", "color_slug", 
		"stk_year", "transmission", "door_count", "seat_count", "fuel_type", 
		"date_created", "date_last_seen", "price_eur" ]
	}
	mutate {convert => ["mileage","float"] }
	mutate {convert => ["manufacture_year","integer"] }
}
output {
    elasticsearch { 
	    hosts => "localhost"
		index => "mydata"
	}
    stdout {}
}
# --- end of logstash config file



### --- ??? --- ###
# _update API
# aggregations
# term
# must / should
# "tokenizer": "standard" 
# "tokenizer": "letter"
# "tokenizer": "uax_url_email"
### --- ??? --- ###



# --- 2018-02-13 ---
GET /_cat/indices?v

# localhost:9200
GET /

# post a document (index name, type name, id)
POST /my-index/my-type/1
{
  "my1": "test101",
  "my2": "test102",
  "my3": "test102"
}

# retrieve a document
GET /my-index/my-type/1

# create your API
GET /my-index/_search
{
  "query": {
    "match": {
      "my1": "test101"
    }
  }
}

# delete API
DELETE /my-index/my-type/1


# create the "library" index
PUT /library
{
  "settings": {
    "index.number_of_shards": 1,
    "index.number_of_replicas": 0
  }
}

# bulk indexing
# when index lots of docs, the bulk API should be used
POST /library/books/_bulk
{"index": {"_id": 1}}
{"title": "my title 1","price": 50, "mycolor": ["my red","my green","my blue"]}
{"index": {"_id": 3}}
{"title": "my title 2","price": 10, "mycolor": ["my black","my green"]}

# search
GET /library/books/_search

# match query to search for multiple terms
# have either "title" or "1"
GET /library/books/_search
{
  "query": {
    "match": {
      "title": "title 1"
    }
  }
}

# search for exact phrase
GET /library/books/_search
{
  "query": {
    "match_phrase": {
      "title": "my title 1"
    }
  }
}

# boolean combinations of querys
GET library/books/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "title"
          }
        },
        {
          "match_phrase": {
            "title": "title 1"
          }
        }
      ]
    }
  }
}

# record doesn't have "1" and phrase - "title 1"
GET /library/books/_search
{
  "query": {
    "bool": {
      "must_not": [
        {
          "match": {
            "title": "1"
          }
        },
        {
          "match_phrase": {
            "title": "title 1"
          }
        }
      ]
    }
  }
}

# combinations can boost scores
GET /library/books/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match_phrase": {
            "title": "my title"
          }
        },
        {
          "match_phrase": {
            "title": {
              "query": "title 2",
              "boost": 3
              
            }
          }
        }
      ]
    }
  }
}


# filter (faster)
GET /library/books/_search
{
 "query": {
   "bool": {
     "must": [
       {
         "match": {
           "title": "my"
         }
       }
     ],
     "filter": {
       "range": {
         "price": {
           "gte": 40,
           "lte": 60
         }
       }
     }
   }
 } 
}

# filter data
GET /library/books/_search
{
  "query": {
    "bool": {
      "filter": {
        "range": {
          "price": {
            "gt": 11
          }
        }
      }
    }
  }
}


# analyze data
GET /library/_analyze
{
  "tokenizer": "standard",
  "filter": ["lowercase","unique"],
  "text": "Brown brown brown fox brown dog"
}

# analyze data
GET /library/_analyze
{
  "tokenizer": "standard",
  "filter": ["lowercase"],
  "text": "Brown.brown $brown fox $ brown @ dog https://www.google.com my@gmail.com"
}

GET /library/_analyze
{
  "tokenizer": "letter",
  "filter": ["lowercase"],
  "text": "Brown.brown $brown fox $ brown @ dog https://www.google.com my@gmail.com"
}

GET /library/_analyze
{
  "tokenizer": "uax_url_email",
  "filter": ["lowercase"],
  "text": "Brown.brown $brown fox $ brown @ dog https://www.google.com my@gmail.com"
}

# aggregations
GET /library/_search
{
  "size": 0, 
  "aggs": {
    "colors": {
      "terms": {
        "field": "mycolor.keyword"
      }
    }
  }
}

# search/aggreate at the same time 
GET /library/_search
{
  "query": {
    "match": {
      "title": "title 2"
    }
  },
  "size": 0, 
  "aggs": {
    "colors": {
      "terms": {
        "field": "mycolor.keyword"
      }
    }
  }
}

# aggregation/average
GET /library/_search
{
  "size": 0,
  "aggs": {
    "price-stat": {
      "stats": {
        "field": "price"
      }
    },
    "popular-colors": {
      "terms": {
        "field": "mycolor.keyword"
      },
      "aggs": {
        "avg-price-per-color": {
          "avg": {
            "field": "price"
          }
        }
      }
    }
  }
}

# documents can be updated by re-indexing them
POST /library/books/1
{
  "title": "new title 1",
  "price": 51,
  "color": ["my red1", "my green1", "my blue1"]
}

# _update API
POST /library/books/1/_update
{
  "doc": {
    "title": "new title using _update API"
  }
}

# elasticsearch will dynamically define schema when docs are indexed
GET /library/_mapping

# define yourself (skip examples)
